{
  "version": 3,
  "sources": ["../../soundtouchjs/src/FifoSampleBuffer.js", "../../soundtouchjs/src/AbstractFifoSamplePipe.js", "../../soundtouchjs/src/RateTransposer.js", "../../soundtouchjs/src/FilterSupport.js", "../../soundtouchjs/src/noop.js", "../../soundtouchjs/src/SimpleFilter.js", "../../soundtouchjs/src/Stretch.js", "../../soundtouchjs/src/testFloatEqual.js", "../../soundtouchjs/src/SoundTouch.js", "../../soundtouchjs/src/WebAudioBufferSource.js", "../../soundtouchjs/src/getWebAudioNode.js", "../../soundtouchjs/src/minsSecs.js", "../../soundtouchjs/src/PitchShifter.js"],
  "sourcesContent": ["/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nexport default class FifoSampleBuffer {\n  constructor() {\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n  }\n\n  get vector() {\n    return this._vector;\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  get startIndex() {\n    return this._position * 2;\n  }\n\n  get frameCount() {\n    return this._frameCount;\n  }\n\n  get endIndex() {\n    return (this._position + this._frameCount) * 2;\n  }\n\n  clear() {\n    this.receive(this._frameCount);\n    this.rewind();\n  }\n\n  put(numFrames) {\n    this._frameCount += numFrames;\n  }\n\n  putSamples(samples, position, numFrames = 0) {\n    position = position || 0;\n    const sourceOffset = position * 2;\n    if (!(numFrames >= 0)) {\n      numFrames = (samples.length - sourceOffset) / 2;\n    }\n    const numSamples = numFrames * 2;\n\n    this.ensureCapacity(numFrames + this._frameCount);\n\n    const destOffset = this.endIndex;\n    this.vector.set(\n      samples.subarray(sourceOffset, sourceOffset + numSamples),\n      destOffset\n    );\n\n    this._frameCount += numFrames;\n  }\n\n  putBuffer(buffer, position, numFrames = 0) {\n    position = position || 0;\n    if (!(numFrames >= 0)) {\n      numFrames = buffer.frameCount - position;\n    }\n    this.putSamples(buffer.vector, buffer.position + position, numFrames);\n  }\n\n  receive(numFrames) {\n    if (!(numFrames >= 0) || numFrames > this._frameCount) {\n      numFrames = this.frameCount;\n    }\n    this._frameCount -= numFrames;\n    this._position += numFrames;\n  }\n\n  receiveSamples(output, numFrames = 0) {\n    const numSamples = numFrames * 2;\n    const sourceOffset = this.startIndex;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    this.receive(numFrames);\n  }\n\n  extract(output, position = 0, numFrames = 0) {\n    const sourceOffset = this.startIndex + position * 2;\n    const numSamples = numFrames * 2;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n  }\n\n  ensureCapacity(numFrames = 0) {\n    const minLength = parseInt(numFrames * 2);\n    if (this._vector.length < minLength) {\n      const newVector = new Float32Array(minLength);\n      newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._vector = newVector;\n      this._position = 0;\n    } else {\n      this.rewind();\n    }\n  }\n\n  ensureAdditionalCapacity(numFrames = 0) {\n    this.ensureCapacity(this._frameCount + numFrames);\n  }\n\n  rewind() {\n    if (this._position > 0) {\n      this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._position = 0;\n    }\n  }\n}\n", "/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport FifoSampleBuffer from './FifoSampleBuffer';\n\nexport default class AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    if (createBuffers) {\n      this._inputBuffer = new FifoSampleBuffer();\n      this._outputBuffer = new FifoSampleBuffer();\n    } else {\n      this._inputBuffer = this._outputBuffer = null;\n    }\n  }\n\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n\n  set inputBuffer(inputBuffer) {\n    this._inputBuffer = inputBuffer;\n  }\n\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n\n  set outputBuffer(outputBuffer) {\n    this._outputBuffer = outputBuffer;\n  }\n\n  clear() {\n    this._inputBuffer.clear();\n    this._outputBuffer.clear();\n  }\n}\n", "/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport AbstractFifoSamplePipe from './AbstractFifoSamplePipe';\n\nexport default class RateTransposer extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this.reset();\n    this._rate = 1;\n  }\n\n  set rate(rate) {\n    this._rate = rate;\n    // TODO: aa filter\n  }\n\n  reset() {\n    this.slopeCount = 0;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n  }\n\n  clone() {\n    const result = new RateTransposer();\n    result.rate = this._rate;\n    return result;\n  }\n\n  process() {\n    // TODO: aa filter\n    const numFrames = this._inputBuffer.frameCount;\n    this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n    const numFramesOutput = this.transpose(numFrames);\n    this._inputBuffer.receive();\n    this._outputBuffer.put(numFramesOutput);\n  }\n\n  transpose(numFrames = 0) {\n    if (numFrames === 0) {\n      return 0;\n    }\n\n    const src = this._inputBuffer.vector;\n    const srcOffset = this._inputBuffer.startIndex;\n\n    const dest = this._outputBuffer.vector;\n    const destOffset = this._outputBuffer.endIndex;\n\n    let used = 0;\n    let i = 0;\n\n    while (this.slopeCount < 1.0) {\n      dest[destOffset + 2 * i] =\n        (1.0 - this.slopeCount) * this.prevSampleL +\n        this.slopeCount * src[srcOffset];\n      dest[destOffset + 2 * i + 1] =\n        (1.0 - this.slopeCount) * this.prevSampleR +\n        this.slopeCount * src[srcOffset + 1];\n      i = i + 1;\n      this.slopeCount += this._rate;\n    }\n\n    this.slopeCount -= 1.0;\n\n    if (numFrames !== 1) {\n      // eslint-disable-next-line no-constant-condition\n      out: while (true) {\n        while (this.slopeCount > 1.0) {\n          this.slopeCount -= 1.0;\n          used = used + 1;\n          if (used >= numFrames - 1) {\n            break out;\n          }\n        }\n\n        const srcIndex = srcOffset + 2 * used;\n        dest[destOffset + 2 * i] =\n          (1.0 - this.slopeCount) * src[srcIndex] +\n          this.slopeCount * src[srcIndex + 2];\n        dest[destOffset + 2 * i + 1] =\n          (1.0 - this.slopeCount) * src[srcIndex + 1] +\n          this.slopeCount * src[srcIndex + 3];\n\n        i = i + 1;\n        this.slopeCount += this._rate;\n      }\n    }\n\n    this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n    this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n\n    return i;\n  }\n}\n", "/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nexport default class FilterSupport {\n  constructor(pipe) {\n    this._pipe = pipe;\n  }\n\n  get pipe() {\n    return this._pipe;\n  }\n\n  get inputBuffer() {\n    return this._pipe.inputBuffer;\n  }\n\n  get outputBuffer() {\n    return this._pipe.outputBuffer;\n  }\n\n  fillInputBuffer(/*numFrames*/) {\n    throw new Error('fillInputBuffer() not overridden');\n  }\n\n  fillOutputBuffer(numFrames = 0) {\n    while (this.outputBuffer.frameCount < numFrames) {\n      // TODO hardcoded buffer size\n      const numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n\n      this.fillInputBuffer(numInputFrames);\n\n      if (this.inputBuffer.frameCount < 8192 * 2) {\n        break;\n        // TODO: flush pipe\n      }\n      this._pipe.process();\n    }\n  }\n\n  clear() {\n    this._pipe.clear();\n  }\n}\n", "const noop = function () {\n  return;\n};\n\nexport default noop;\n", "/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport FilterSupport from './FilterSupport';\nimport noop from './noop';\n\nexport default class SimpleFilter extends FilterSupport {\n  constructor(sourceSound, pipe, callback = noop) {\n    super(pipe);\n    this.callback = callback;\n    this.sourceSound = sourceSound;\n    //this.bufferDuration = sourceSound.buffer.duration;\n    this.historyBufferSize = 22050;\n    this._sourcePosition = 0;\n    this.outputBufferPosition = 0;\n    this._position = 0;\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  set position(position) {\n    if (position > this._position) {\n      throw new RangeError(\n        'New position may not be greater than current position'\n      );\n    }\n    const newOutputBufferPosition =\n      this.outputBufferPosition - (this._position - position);\n    if (newOutputBufferPosition < 0) {\n      throw new RangeError('New position falls outside of history buffer');\n    }\n    this.outputBufferPosition = newOutputBufferPosition;\n    this._position = position;\n  }\n\n  get sourcePosition() {\n    return this._sourcePosition;\n  }\n\n  set sourcePosition(sourcePosition) {\n    this.clear();\n    this._sourcePosition = sourcePosition;\n  }\n\n  onEnd() {\n    this.callback();\n  }\n\n  fillInputBuffer(numFrames = 0) {\n    const samples = new Float32Array(numFrames * 2);\n    const numFramesExtracted = this.sourceSound.extract(\n      samples,\n      numFrames,\n      this._sourcePosition\n    );\n    this._sourcePosition += numFramesExtracted;\n    this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n  }\n\n  extract(target, numFrames = 0) {\n    this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n\n    const numFramesExtracted = Math.min(\n      numFrames,\n      this.outputBuffer.frameCount - this.outputBufferPosition\n    );\n    this.outputBuffer.extract(\n      target,\n      this.outputBufferPosition,\n      numFramesExtracted\n    );\n\n    const currentFrames = this.outputBufferPosition + numFramesExtracted;\n    this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n    this.outputBuffer.receive(\n      Math.max(currentFrames - this.historyBufferSize, 0)\n    );\n\n    this._position += numFramesExtracted;\n    return numFramesExtracted;\n  }\n\n  handleSampleData(event) {\n    this.extract(event.data, 4096);\n  }\n\n  clear() {\n    super.clear();\n    this.outputBufferPosition = 0;\n  }\n}\n", "/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport AbstractFifoSamplePipe from './AbstractFifoSamplePipe';\n\n/**\n * Giving this value for the sequence length sets automatic parameter value\n * according to tempo setting (recommended)\n */\nconst USE_AUTO_SEQUENCE_LEN = 0;\n\n/**\n * Default length of a single processing sequence, in milliseconds. This determines to how\n * long sequences the original sound is chopped in the time-stretch algorithm.\n *\n * The larger this value is, the lesser sequences are used in processing. In principle\n * a bigger value sounds better when slowing down tempo, but worse when increasing tempo\n * and vice versa.\n *\n * Increasing this value reduces computational burden and vice versa.\n */\n//const DEFAULT_SEQUENCE_MS = 130\nconst DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\n\n/**\n * Giving this value for the seek window length sets automatic parameter value\n * according to tempo setting (recommended)\n */\nconst USE_AUTO_SEEKWINDOW_LEN = 0;\n\n/**\n * Seeking window default length in milliseconds for algorithm that finds the best possible\n * overlapping location. This determines from how wide window the algorithm may look for an\n * optimal joining location when mixing the sound sequences back together.\n *\n * The bigger this window setting is, the higher the possibility to find a better mixing\n * position will become, but at the same time large values may cause a 'drifting' artifact\n * because consequent sequences will be taken at more uneven intervals.\n *\n * If there's a disturbing artifact that sounds as if a constant frequency was drifting\n * around, try reducing this setting.\n *\n * Increasing this value increases computational burden and vice versa.\n */\n//const DEFAULT_SEEKWINDOW_MS = 25;\nconst DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\n\n/**\n * Overlap length in milliseconds. When the chopped sound sequences are mixed back together,\n * to form a continuous sound stream, this parameter defines over how long period the two\n * consecutive sequences are let to overlap each other.\n *\n * This shouldn't be that critical parameter. If you reduce the DEFAULT_SEQUENCE_MS setting\n * by a large amount, you might wish to try a smaller value on this.\n *\n * Increasing this value increases computational burden and vice versa.\n */\nconst DEFAULT_OVERLAP_MS = 8;\n\n// Table for the hierarchical mixing position seeking algorithm\nconst _SCAN_OFFSETS = [\n  [\n    124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992,\n    1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0,\n  ],\n  [\n    -100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0,\n  ],\n  [\n    -20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0,\n  ],\n  [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n];\n\n// Adjust tempo param according to tempo, so that variating processing sequence length is used\n// at varius tempo settings, between the given low...top limits\nconst AUTOSEQ_TEMPO_LOW = 0.25; // auto setting low tempo range (-25%)\nconst AUTOSEQ_TEMPO_TOP = 4.0; // auto setting top tempo range (+100%)\n\n// sequence-ms setting values at above low & top tempo\nconst AUTOSEQ_AT_MIN = 125.0;\nconst AUTOSEQ_AT_MAX = 50.0;\nconst AUTOSEQ_K =\n  (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW;\n\n// seek-window-ms setting values at above low & top tempo\nconst AUTOSEEK_AT_MIN = 25.0;\nconst AUTOSEEK_AT_MAX = 15.0;\nconst AUTOSEEK_K =\n  (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\n\nexport default class Stretch extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this._quickSeek = true;\n    this.midBufferDirty = false;\n\n    this.midBuffer = null;\n    this.overlapLength = 0;\n\n    this.autoSeqSetting = true;\n    this.autoSeekSetting = true;\n\n    this._tempo = 1;\n    this.setParameters(\n      44100,\n      DEFAULT_SEQUENCE_MS,\n      DEFAULT_SEEKWINDOW_MS,\n      DEFAULT_OVERLAP_MS\n    );\n  }\n\n  clear() {\n    super.clear();\n    this.clearMidBuffer();\n  }\n\n  clearMidBuffer() {\n    if (this.midBufferDirty) {\n      this.midBufferDirty = false;\n      this.midBuffer = null;\n    }\n  }\n\n  /**\n   * Sets routine control parameters. These control are certain time constants\n   * defining how the sound is stretched to the desired duration.\n   *\n   * 'sampleRate' = sample rate of the sound\n   * 'sequenceMS' = one processing sequence length in milliseconds (default = 82 ms)\n   * 'seekwindowMS' = seeking window length for scanning the best overlapping\n   *      position (default = 28 ms)\n   * 'overlapMS' = overlapping length (default = 12 ms)\n   */\n  setParameters(sampleRate, sequenceMs, seekWindowMs, overlapMs) {\n    // accept only positive parameter values - if zero or negative, use old values instead\n    if (sampleRate > 0) {\n      this.sampleRate = sampleRate;\n    }\n\n    if (overlapMs > 0) {\n      this.overlapMs = overlapMs;\n    }\n\n    if (sequenceMs > 0) {\n      this.sequenceMs = sequenceMs;\n      this.autoSeqSetting = false;\n    } else {\n      // zero or below, use automatic setting\n      this.autoSeqSetting = true;\n    }\n\n    if (seekWindowMs > 0) {\n      this.seekWindowMs = seekWindowMs;\n      this.autoSeekSetting = false;\n    } else {\n      // zero or below, use automatic setting\n      this.autoSeekSetting = true;\n    }\n\n    this.calculateSequenceParameters();\n\n    this.calculateOverlapLength(this.overlapMs);\n\n    // set tempo to recalculate 'sampleReq'\n    this.tempo = this._tempo;\n  }\n\n  /**\n   * Sets new target tempo. Normal tempo = 'SCALE', smaller values represent slower\n   * tempo, larger faster tempo.\n   */\n  set tempo(newTempo) {\n    let intskip;\n\n    this._tempo = newTempo;\n\n    // Calculate new sequence duration\n    this.calculateSequenceParameters();\n\n    // Calculate ideal skip length (according to tempo value)\n    this.nominalSkip =\n      this._tempo * (this.seekWindowLength - this.overlapLength);\n    this.skipFract = 0;\n    intskip = Math.floor(this.nominalSkip + 0.5);\n\n    // Calculate how many samples are needed in the 'inputBuffer' to process another batch of samples\n    this.sampleReq =\n      Math.max(intskip + this.overlapLength, this.seekWindowLength) +\n      this.seekLength;\n  }\n\n  get tempo() {\n    return this._tempo;\n  }\n\n  get inputChunkSize() {\n    return this.sampleReq;\n  }\n\n  get outputChunkSize() {\n    return (\n      this.overlapLength +\n      Math.max(0, this.seekWindowLength - 2 * this.overlapLength)\n    );\n  }\n\n  /**\n   * Calculates overlapInMsec period length in samples.\n   */\n  calculateOverlapLength(overlapInMsec = 0) {\n    let newOvl;\n\n    // TODO assert(overlapInMsec >= 0);\n    newOvl = (this.sampleRate * overlapInMsec) / 1000;\n    newOvl = newOvl < 16 ? 16 : newOvl;\n\n    // must be divisible by 8\n    newOvl -= newOvl % 8;\n\n    this.overlapLength = newOvl;\n\n    this.refMidBuffer = new Float32Array(this.overlapLength * 2);\n    this.midBuffer = new Float32Array(this.overlapLength * 2);\n  }\n\n  checkLimits(x, mi, ma) {\n    return x < mi ? mi : x > ma ? ma : x;\n  }\n\n  /**\n   * Calculates processing sequence length according to tempo setting\n   */\n  calculateSequenceParameters() {\n    let seq;\n    let seek;\n\n    if (this.autoSeqSetting) {\n      seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n      seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n      this.sequenceMs = Math.floor(seq + 0.5);\n    }\n\n    if (this.autoSeekSetting) {\n      seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n      seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n      this.seekWindowMs = Math.floor(seek + 0.5);\n    }\n\n    // Update seek window lengths\n    this.seekWindowLength = Math.floor(\n      (this.sampleRate * this.sequenceMs) / 1000\n    );\n    this.seekLength = Math.floor((this.sampleRate * this.seekWindowMs) / 1000);\n  }\n\n  /**\n   * Enables/disables the quick position seeking algorithm.\n   */\n  set quickSeek(enable) {\n    this._quickSeek = enable;\n  }\n\n  clone() {\n    const result = new Stretch();\n    result.tempo = this._tempo;\n    result.setParameters(\n      this.sampleRate,\n      this.sequenceMs,\n      this.seekWindowMs,\n      this.overlapMs\n    );\n    return result;\n  }\n\n  /**\n   * Seeks for the optimal overlap-mixing position.\n   */\n  seekBestOverlapPosition() {\n    return this._quickSeek\n      ? this.seekBestOverlapPositionStereoQuick()\n      : this.seekBestOverlapPositionStereo();\n  }\n\n  /**\n   * Seeks for the optimal overlap-mixing position. The 'stereo' version of the\n   * routine\n   *\n   * The best position is determined as the position where the two overlapped\n   * sample sequences are 'most alike', in terms of the highest cross-correlation\n   * value over the overlapping period\n   */\n  seekBestOverlapPositionStereo() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let i = 0;\n\n    // Slopes the amplitudes of the 'midBuffer' samples\n    this.preCalculateCorrelationReferenceStereo();\n\n    bestOffset = 0;\n    bestCorrelation = Number.MIN_VALUE;\n\n    // Scans for the best correlation value by testing each possible position over the permitted range\n    for (; i < this.seekLength; i = i + 1) {\n      // Calculates correlation value for the mixing position corresponding to 'i'\n      correlation = this.calculateCrossCorrelationStereo(\n        2 * i,\n        this.refMidBuffer\n      );\n\n      // Checks for the highest correlation value\n      if (correlation > bestCorrelation) {\n        bestCorrelation = correlation;\n        bestOffset = i;\n      }\n    }\n\n    return bestOffset;\n  }\n\n  /**\n   * Seeks for the optimal overlap-mixing position. The 'stereo' version of the\n   * routine\n   *\n   * The best position is determined as the position where the two overlapped\n   * sample sequences are 'most alike', in terms of the highest cross-correlation\n   * value over the overlapping period\n   */\n  seekBestOverlapPositionStereoQuick() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let scanCount = 0;\n    let correlationOffset;\n    let tempOffset;\n\n    // Slopes the amplitude of the 'midBuffer' samples\n    this.preCalculateCorrelationReferenceStereo();\n\n    bestCorrelation = Number.MIN_VALUE;\n    bestOffset = 0;\n    correlationOffset = 0;\n    tempOffset = 0;\n\n    // Scans for the best correlation value using four-pass hierarchical search.\n    //\n    // The look-up table 'scans' has hierarchical position adjusting steps.\n    // In first pass the routine searhes for the highest correlation with\n    // relatively coarse steps, then rescans the neighbourhood of the highest\n    // correlation with better resolution and so on.\n    for (; scanCount < 4; scanCount = scanCount + 1) {\n      let j = 0;\n      while (_SCAN_OFFSETS[scanCount][j]) {\n        tempOffset = correlationOffset + _SCAN_OFFSETS[scanCount][j];\n        if (tempOffset >= this.seekLength) {\n          break;\n        }\n\n        // Calculates correlation value for the mixing position corresponding to 'tempOffset'\n        correlation = this.calculateCrossCorrelationStereo(\n          2 * tempOffset,\n          this.refMidBuffer\n        );\n\n        // Checks for the highest correlation value\n        if (correlation > bestCorrelation) {\n          bestCorrelation = correlation;\n          bestOffset = tempOffset;\n        }\n        j = j + 1;\n      }\n      correlationOffset = bestOffset;\n    }\n\n    return bestOffset;\n  }\n\n  /**\n   * Slopes the amplitude of the 'midBuffer' samples so that cross correlation\n   * is faster to calculate\n   */\n  preCalculateCorrelationReferenceStereo() {\n    let i = 0;\n    let context;\n    let temp;\n\n    for (; i < this.overlapLength; i = i + 1) {\n      temp = i * (this.overlapLength - i);\n      context = i * 2;\n      this.refMidBuffer[context] = this.midBuffer[context] * temp;\n      this.refMidBuffer[context + 1] = this.midBuffer[context + 1] * temp;\n    }\n  }\n\n  calculateCrossCorrelationStereo(mixingPosition, compare) {\n    const mixing = this._inputBuffer.vector;\n    mixingPosition += this._inputBuffer.startIndex;\n\n    let correlation = 0;\n    let i = 2;\n    const calcLength = 2 * this.overlapLength;\n    let mixingOffset;\n\n    for (; i < calcLength; i = i + 2) {\n      mixingOffset = i + mixingPosition;\n      correlation +=\n        mixing[mixingOffset] * compare[i] +\n        mixing[mixingOffset + 1] * compare[i + 1];\n    }\n\n    return correlation;\n  }\n\n  // TODO inline\n  /**\n   * Overlaps samples in 'midBuffer' with the samples in 'pInputBuffer' at position\n   * of 'ovlPos'.\n   */\n  overlap(overlapPosition) {\n    this.overlapStereo(2 * overlapPosition);\n  }\n\n  /**\n   * Overlaps samples in 'midBuffer' with the samples in 'pInput'\n   */\n  overlapStereo(inputPosition) {\n    const input = this._inputBuffer.vector;\n    inputPosition += this._inputBuffer.startIndex;\n\n    const output = this._outputBuffer.vector;\n    const outputPosition = this._outputBuffer.endIndex;\n\n    let i = 0;\n    let context;\n    let tempFrame;\n    const frameScale = 1 / this.overlapLength;\n    let fi;\n    let inputOffset;\n    let outputOffset;\n\n    for (; i < this.overlapLength; i = i + 1) {\n      tempFrame = (this.overlapLength - i) * frameScale;\n      fi = i * frameScale;\n      context = 2 * i;\n      inputOffset = context + inputPosition;\n      outputOffset = context + outputPosition;\n      output[outputOffset + 0] =\n        input[inputOffset + 0] * fi + this.midBuffer[context + 0] * tempFrame;\n      output[outputOffset + 1] =\n        input[inputOffset + 1] * fi + this.midBuffer[context + 1] * tempFrame;\n    }\n  }\n\n  process() {\n    let offset;\n    let temp;\n    let overlapSkip;\n\n    if (this.midBuffer === null) {\n      // if midBuffer is empty, move the first samples of the input stream into it\n      if (this._inputBuffer.frameCount < this.overlapLength) {\n        // wait until we've got the overlapLength samples\n        return;\n      }\n      this.midBuffer = new Float32Array(this.overlapLength * 2);\n      this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);\n    }\n\n    // Process samples as long as there are enough samples in 'inputBuffer' to form a processing frame\n    while (this._inputBuffer.frameCount >= this.sampleReq) {\n      // If tempo differs from the normal ('SCALE'), scan for hte best overlapping position\n      offset = this.seekBestOverlapPosition();\n\n      /**\n       * Mix the samples in the 'inputBuffer' at position of 'offset' with the samples in 'midBuffer'\n       * using sliding overlapping\n       * ... first partially overlap with the end of the previous sequence (that's in 'midBuffer')\n       */\n      this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n      // FIXME unit?\n      // overlap(uint(offset));\n      this.overlap(Math.floor(offset));\n      this._outputBuffer.put(this.overlapLength);\n\n      // ... then copy sequence samples from 'inputBuffer' to output\n      temp = this.seekWindowLength - 2 * this.overlapLength; // & 0xfffffffe;\n      if (temp > 0) {\n        this._outputBuffer.putBuffer(\n          this._inputBuffer,\n          offset + this.overlapLength,\n          temp\n        );\n      }\n\n      /**\n       * Copies the end of the current sequence from 'inputBuffer' to 'midBuffer' for being mixed with\n       * the beginning of the next processing sequence and so on\n       */\n      // assert(offset + seekWindowLength <= (int)inputBuffer.numSamples());\n      const start =\n        this._inputBuffer.startIndex +\n        2 * (offset + this.seekWindowLength - this.overlapLength);\n      this.midBuffer.set(\n        this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength)\n      );\n\n      /**\n       * Remove the processed samples from the input buffer. Update the difference between\n       * integer & nominal skip step to 'skipFract' in order to prevent the error from\n       * accumulating over time\n       */\n      this.skipFract += this.nominalSkip; // real skip size\n      overlapSkip = Math.floor(this.skipFract);\n      this.skipFract -= overlapSkip;\n      this._inputBuffer.receive(overlapSkip);\n    }\n  }\n}\n", "const testFloatEqual = function (a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n};\n\nexport default testFloatEqual;\n", "/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport RateTransposer from './RateTransposer';\nimport Stretch from './Stretch';\nimport FifoSampleBuffer from './FifoSampleBuffer';\nimport testFloatEqual from './testFloatEqual';\n\nexport default class SoundTouch {\n  constructor() {\n    this.transposer = new RateTransposer(false);\n    this.stretch = new Stretch(false);\n\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n\n    this._rate = 0;\n    this._tempo = 0;\n\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  clear() {\n    this.transposer.clear();\n    this.stretch.clear();\n  }\n\n  clone() {\n    const result = new SoundTouch();\n    result.rate = this.rate;\n    result.tempo = this.tempo;\n    return result;\n  }\n\n  get rate() {\n    return this._rate;\n  }\n\n  set rate(rate) {\n    this.virtualRate = rate;\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  set rateChange(rateChange) {\n    this._rate = 1.0 + 0.01 * rateChange;\n  }\n\n  get tempo() {\n    return this._tempo;\n  }\n\n  set tempo(tempo) {\n    this.virtualTempo = tempo;\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  set tempoChange(tempoChange) {\n    this.tempo = 1.0 + 0.01 * tempoChange;\n  }\n\n  set pitch(pitch) {\n    this.virtualPitch = pitch;\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  set pitchOctaves(pitchOctaves) {\n    this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  set pitchSemitones(pitchSemitones) {\n    this.pitchOctaves = pitchSemitones / 12.0;\n  }\n\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n\n  calculateEffectiveRateAndTempo() {\n    const previousTempo = this._tempo;\n    const previousRate = this._rate;\n\n    this._tempo = this.virtualTempo / this.virtualPitch;\n    this._rate = this.virtualRate * this.virtualPitch;\n\n    if (testFloatEqual(this._tempo, previousTempo)) {\n      this.stretch.tempo = this._tempo;\n    }\n    if (testFloatEqual(this._rate, previousRate)) {\n      this.transposer.rate = this._rate;\n    }\n\n    if (this._rate > 1.0) {\n      if (this._outputBuffer != this.transposer.outputBuffer) {\n        this.stretch.inputBuffer = this._inputBuffer;\n        this.stretch.outputBuffer = this._intermediateBuffer;\n\n        this.transposer.inputBuffer = this._intermediateBuffer;\n        this.transposer.outputBuffer = this._outputBuffer;\n      }\n    } else {\n      if (this._outputBuffer != this.stretch.outputBuffer) {\n        this.transposer.inputBuffer = this._inputBuffer;\n        this.transposer.outputBuffer = this._intermediateBuffer;\n\n        this.stretch.inputBuffer = this._intermediateBuffer;\n        this.stretch.outputBuffer = this._outputBuffer;\n      }\n    }\n  }\n\n  process() {\n    if (this._rate > 1.0) {\n      this.stretch.process();\n      this.transposer.process();\n    } else {\n      this.transposer.process();\n      this.stretch.process();\n    }\n  }\n}\n", "/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nexport default class WebAudioBufferSource {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._position = 0;\n  }\n\n  get dualChannel() {\n    return this.buffer.numberOfChannels > 1;\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  set position(value) {\n    this._position = value;\n  }\n\n  extract(target, numFrames = 0, position = 0) {\n    this.position = position;\n    let left = this.buffer.getChannelData(0);\n    let right = this.dualChannel\n      ? this.buffer.getChannelData(1)\n      : this.buffer.getChannelData(0);\n    let i = 0;\n    for (; i < numFrames; i++) {\n      target[i * 2] = left[i + position];\n      target[i * 2 + 1] = right[i + position];\n    }\n    return Math.min(numFrames, left.length - position);\n  }\n}\n", "import noop from './noop';\n/**\n * getWebAudioNode\n *\n * A wrapper to create an AudioNode and apply a filter for frame extraction\n * Copyright (c) Adrian Holovary https://github.com/adrianholovaty\n *\n * @param context - AudioContext\n * @param filter - Object containing an 'extract()' method\n * @param bufferSize - units of sample frames (256, 512, 1024, 2048, 4096, 8192, 16384)\n * @returns {ScriptProcessorNode}\n */\nconst getWebAudioNode = function (\n  context,\n  filter,\n  sourcePositionCallback = noop,\n  bufferSize = 4096\n) {\n  const node = context.createScriptProcessor(bufferSize, 2, 2);\n  const samples = new Float32Array(bufferSize * 2);\n\n  node.onaudioprocess = (event) => {\n    let left = event.outputBuffer.getChannelData(0);\n    let right = event.outputBuffer.getChannelData(1);\n    let framesExtracted = filter.extract(samples, bufferSize);\n    sourcePositionCallback(filter.sourcePosition);\n    if (framesExtracted === 0) {\n      filter.onEnd();\n    }\n    let i = 0;\n    for (; i < framesExtracted; i++) {\n      left[i] = samples[i * 2];\n      right[i] = samples[i * 2 + 1];\n    }\n  };\n  return node;\n};\n\nexport default getWebAudioNode;\n", "const pad = function (n, width, z) {\n  z = z || '0';\n  n = n + '';\n  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n};\n\nconst minsSecs = function (secs) {\n  const mins = Math.floor(secs / 60);\n  const seconds = secs - mins * 60;\n  return `${mins}:${pad(parseInt(seconds), 2)}`;\n};\n\nexport default minsSecs;\n", "/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport WebAudioBufferSource from './WebAudioBufferSource';\nimport getWebAudioNode from './getWebAudioNode';\nimport SoundTouch from './SoundTouch';\nimport SimpleFilter from './SimpleFilter';\nimport minsSecs from './minsSecs';\nimport noop from './noop';\n\nconst onUpdate = function (sourcePosition) {\n  const currentTimePlayed = this.timePlayed;\n  const sampleRate = this.sampleRate;\n  this.sourcePosition = sourcePosition;\n  this.timePlayed = sourcePosition / sampleRate;\n  if (currentTimePlayed !== this.timePlayed) {\n    const timePlayed = new CustomEvent('play', {\n      detail: {\n        timePlayed: this.timePlayed,\n        formattedTimePlayed: this.formattedTimePlayed,\n        percentagePlayed: this.percentagePlayed,\n      },\n    });\n    this._node.dispatchEvent(timePlayed);\n  }\n};\n\nexport default class PitchShifter {\n  constructor(context, buffer, bufferSize, onEnd = noop) {\n    this._soundtouch = new SoundTouch();\n    const source = new WebAudioBufferSource(buffer);\n    this.timePlayed = 0;\n    this.sourcePosition = 0;\n    this._filter = new SimpleFilter(source, this._soundtouch, onEnd);\n    this._node = getWebAudioNode(\n      context,\n      this._filter,\n      (sourcePostion) => onUpdate.call(this, sourcePostion),\n      bufferSize\n    );\n    this.tempo = 1;\n    this.rate = 1;\n    this.duration = buffer.duration;\n    this.sampleRate = context.sampleRate;\n    this.listeners = [];\n  }\n\n  get formattedDuration() {\n    return minsSecs(this.duration);\n  }\n\n  get formattedTimePlayed() {\n    return minsSecs(this.timePlayed);\n  }\n\n  get percentagePlayed() {\n    return (\n      (100 * this._filter.sourcePosition) / (this.duration * this.sampleRate)\n    );\n  }\n\n  set percentagePlayed(perc) {\n    this._filter.sourcePosition = parseInt(\n      perc * this.duration * this.sampleRate\n    );\n    this.sourcePosition = this._filter.sourcePosition;\n    this.timePlayed = this.sourcePosition / this.sampleRate;\n  }\n\n  get node() {\n    return this._node;\n  }\n\n  set pitch(pitch) {\n    this._soundtouch.pitch = pitch;\n  }\n\n  set pitchSemitones(semitone) {\n    this._soundtouch.pitchSemitones = semitone;\n  }\n\n  set rate(rate) {\n    this._soundtouch.rate = rate;\n  }\n\n  set tempo(tempo) {\n    this._soundtouch.tempo = tempo;\n  }\n\n  connect(toNode) {\n    this._node.connect(toNode);\n  }\n\n  disconnect() {\n    this._node.disconnect();\n  }\n\n  on(eventName, cb) {\n    this.listeners.push({ name: eventName, cb: cb });\n    this._node.addEventListener(eventName, (event) => cb(event.detail));\n  }\n\n  off(eventName = null) {\n    let listeners = this.listeners;\n    if (eventName) {\n      listeners = listeners.filter((e) => e.name === eventName);\n    }\n    listeners.forEach((e) => {\n      this._node.removeEventListener(e.name, (event) => e.cb(event.detail));\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["FifoSampleBuffer", "constructor", "_vector", "Float32Array", "_position", "_frameCount", "vector", "position", "startIndex", "frameCount", "endIndex", "clear", "receive", "rewind", "put", "numFrames", "putSamples", "samples", "sourceOffset", "length", "numSamples", "ensureCapacity", "destOffset", "set", "subarray", "putBuffer", "buffer", "receiveSamples", "output", "extract", "minLength", "parseInt", "newVector", "ensureAdditionalCapacity", "AbstractFifoSamplePipe", "createBuffers", "_inputBuffer", "_outputBuffer", "inputBuffer", "outputBuffer", "RateTransposer", "reset", "_rate", "rate", "slopeCount", "prevSampleL", "prevSampleR", "clone", "result", "process", "numFramesOutput", "transpose", "src", "srcOffset", "dest", "used", "i", "out", "srcIndex", "FilterSupport", "pipe", "_pipe", "fillInputBuffer", "Error", "fillOutputBuffer", "numInputFrames", "noop", "SimpleFilter", "sourceSound", "callback", "historyBufferSize", "_sourcePosition", "outputBufferPosition", "RangeError", "newOutputBufferPosition", "sourcePosition", "onEnd", "numFramesExtracted", "target", "Math", "min", "currentFrames", "max", "handleSampleData", "event", "data", "USE_AUTO_SEQUENCE_LEN", "DEFAULT_SEQUENCE_MS", "USE_AUTO_SEEKWINDOW_LEN", "DEFAULT_SEEKWINDOW_MS", "DEFAULT_OVERLAP_MS", "_SCAN_OFFSETS", "AUTOSEQ_TEMPO_LOW", "AUTOSEQ_TEMPO_TOP", "AUTOSEQ_AT_MIN", "AUTOSEQ_AT_MAX", "AUTOSEQ_K", "AUTOSEQ_C", "AUTOSEEK_AT_MIN", "AUTOSEEK_AT_MAX", "AUTOSEEK_K", "AUTOSEEK_C", "Stretch", "_quickSeek", "midBufferDirty", "midBuffer", "overlapLength", "autoSeqSetting", "autoSeekSetting", "_tempo", "setParameters", "clearMidBuffer", "sampleRate", "sequenceMs", "seekWindowMs", "overlapMs", "calculateSequenceParameters", "calculateOverlapLength", "tempo", "newTempo", "intskip", "nominalSkip", "seekWindowLength", "skipFract", "floor", "sampleReq", "seekLength", "inputChunkSize", "outputChunkSize", "overlapInMsec", "newOvl", "refMidBuffer", "checkLimits", "x", "mi", "ma", "seq", "seek", "quickSeek", "enable", "seekBestOverlapPosition", "seekBestOverlapPositionStereoQuick", "seekBestOverlapPositionStereo", "bestOffset", "bestCorrelation", "correlation", "preCalculateCorrelationReferenceStereo", "Number", "MIN_VALUE", "calculateCrossCorrelationStereo", "scanCount", "correlationOffset", "tempOffset", "j", "context", "temp", "mixingPosition", "compare", "mixing", "calcLength", "mixingOffset", "overlap", "overlapPosition", "overlapStereo", "inputPosition", "input", "outputPosition", "tempFrame", "frameScale", "fi", "inputOffset", "outputOffset", "offset", "overlapSkip", "start", "testFloatEqual", "a", "b", "SoundTouch", "transposer", "stretch", "_intermediateBuffer", "virtualPitch", "virtualRate", "virtualTempo", "calculateEffectiveRateAndTempo", "rateChange", "tempoChange", "pitch", "pitchOctaves", "exp", "pitchSemitones", "previousTempo", "previousRate", "WebAudioBufferSource", "dualChannel", "numberOfChannels", "value", "left", "getChannelData", "right", "getWebAudioNode", "filter", "sourcePositionCallback", "bufferSize", "node", "createScriptProcessor", "onaudioprocess", "framesExtracted", "pad", "n", "width", "z", "Array", "join", "minsSecs", "secs", "mins", "seconds", "onUpdate", "currentTimePlayed", "timePlayed", "CustomEvent", "detail", "formattedTimePlayed", "percentagePlayed", "_node", "dispatchEvent", "PitchShifter", "_soundtouch", "source", "_filter", "sourcePostion", "call", "duration", "listeners", "formattedDuration", "perc", "semitone", "connect", "toNode", "disconnect", "on", "eventName", "cb", "push", "name", "addEventListener", "off", "e", "forEach", "removeEventListener"]
}
